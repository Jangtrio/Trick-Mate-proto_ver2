<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Trick Mate 프로토타입</title>
<style>
:root{
  /* 배경/패널 기본 톤 */
  --bg:#bdf4b8;          /* 전체 배경 연녹색 */
  --panel:#fffdf5;       /* 메인 카드(패널) */
  --panel2:#ffecc2;      /* 버튼/보조 패널 */
  --line:#e2e8d8;        /* 연한 라인 */
  --text:#334155;        /* 본문 텍스트 */
  --muted:#94a3b8;
  --accent:#22c55e;      /* 초록 포인트 */
  --danger:#fb7185;
  --ok:#4ade80;          /* HP 바 색 */
}

*{
  box-sizing:border-box;
  font-family:system-ui,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,sans-serif
}

body{
  margin:0;
  background:radial-gradient(circle at top,#d7fdd2 0,#bdf4b8 40%,#a7e6ab 100%);
  color:var(--text);
}

/* 메인 카드 래퍼 */
.wrap{
  max-width:1160px;
  margin:28px auto;
  padding:24px 24px 20px;
  background:var(--panel);
  border-radius:26px;
  box-shadow:
    0 18px 35px rgba(0,0,0,.12),
    0 0 0 3px rgba(255,255,255,.6);
}

/* 상단 바 */
.topbar{
  display:flex;
  gap:10px;
  align-items:center;
  background:transparent;
  border-radius:18px;
  padding:6px 4px 10px;
}

/* 버튼 */
.btn{
  background:var(--panel2);
  border:1px solid #facc6b;
  color:#78350f;
  padding:8px 14px;
  border-radius:18px;
  cursor:pointer;
  user-select:none;
  font-weight:600;
  box-shadow:0 3px 0 #fbbf24;
  transition:transform .08s ease, box-shadow .08s ease, filter .1s ease;
}
.btn:hover{
  filter:brightness(1.03);
}
.btn:active{
  transform:translateY(2px);
  box-shadow:0 1px 0 #fbbf24;
}
.btn[disabled]{
  opacity:.6;
  cursor:not-allowed;
  box-shadow:none;
}
.btn-danger{
  border-color:#fb7185;
  background:#ffe4e6;
  color:#b91c1c;
  box-shadow:0 3px 0 #fb7185;
}

/* 알약형 태그 */
.pill{
  padding:6px 10px;
  border-radius:999px;
  background:#ecfdf5;
  border:1px solid #bbf7d0;
  font-weight:600;
  font-size:12px;
  color:#166534;
}

/* 보드 레이아웃 */
.boards{
  display:grid;
  grid-template-columns:1fr 300px 1fr;
  gap:16px;
  margin-top:18px;
}

/* 보드 자체 */
.board{
  display:grid;
  grid-template-columns:repeat(5,1fr);
  grid-auto-rows:1fr;           /* 모든 셀 정사각형 비율 유지 */
  aspect-ratio:1;
  background:#e6ffd4;
  border-radius:22px;
  padding:10px;
  border:2px solid #22c55e;
  box-shadow:inset 0 0 0 4px rgba(34,197,94,.16);
}

/* 보드 셀 */
.cell{
  border:1px solid #c7f0b4;     /* 연한 격자 */
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:700;
  position:relative;
  font-size:12px;
  padding:2px;
  text-align:center;
  background:rgba(255,255,255,.55);
  border-radius:6px;
  min-width:0;
  min-height:0;
  overflow:hidden;              /* 내부 내용이 커도 보드가 늘어나지 않도록 */
}
.cell:hover{
  outline:2px solid rgba(34,197,94,.28);
  outline-offset:-2px;
  cursor:pointer;
}
.cell.preview::after{
  content:"";
  position:absolute;
  inset:0;
  border-radius:6px;
  background:rgba(56,189,248,.22);
}
/* 적중 / 파괴 칸: 더 진한 붉은색 + 영구 표시용 */
.cell.hit{
  background:rgba(248,113,113,.6);
}
.cell.kill{
  background:rgba(185,28,28,.78);
}

/* AI 기물 파괴 후 X 표시 */
.kill-x{
  position:absolute;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:900;
  color:#fef2f2;
  font-size:22px;
  text-shadow:0 0 4px rgba(0,0,0,.5);
  pointer-events:none;
}

/* 중앙 패널 영역 */
.zone{
  display:flex;
  flex-direction:column;
  gap:12px;
}
.panel{
  background:#fefcf5;
  border:1px solid var(--line);
  border-radius:20px;
  padding:12px 14px;
  box-shadow:0 4px 10px rgba(148,163,184,.18);
}

/* 리저브 영역 */
.reserve{
  display:grid;
  grid-template-columns:repeat(2,1fr);
  gap:8px;
}
.chip{
  padding:8px 10px;
  border-radius:16px;
  border:1px solid #e2e8f0;
  text-align:center;
  background:#f9fafb;
  cursor:pointer;
  user-select:none;
  font-size:13px;
  color:#0f172a;
  box-shadow:0 2px 0 rgba(148,163,184,.4);
}
.chip.sel{
  outline:2px solid #22c55e;
}

/* 로그 */
.log{
  height:120px;
  overflow:auto;
  background:#f8fafc;
  border:1px solid #dbeafe;
  border-radius:16px;
  padding:10px 12px;
  margin-top:18px;
  font-size:13px;
  color:#0f172a;
}

/* 기타 레이아웃 */
.row{display:flex;gap:12px;align-items:center}
.center{display:flex;align-items:center;justify-content:center}

/* 오버레이 */
.overlay{
  position:fixed;
  inset:0;
  background:rgba(15,23,42,.22);
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:5;
}
.overlay .start{
  background:#fffef7;
  border:1px solid #e2e8f0;
  border-radius:24px;
  padding:26px 30px 22px;
  box-shadow:0 18px 40px rgba(15,23,42,.3);
  text-align:center;
  min-width:260px;
}
.overlay .start h1{
  margin:0 0 8px 0;
  font-size:20px;
  color:#111827;
}

/* 배지/상태 */
.badge{
  display:inline-block;
  padding:4px 8px;
  border:1px solid #bbf7d0;
  border-radius:999px;
  background:#ecfdf5;
  margin-left:6px;
  font-size:12px;
  color:#166534;
}
.status{
  min-width:120px;
  text-align:center;
  background:#eff6ff;
  border-color:#bfdbfe;
  color:#1d4ed8;
}
small{color:var(--muted)}

/* 스피너 */
.spinner{
  width:36px;
  height:36px;
  border:3px solid rgba(125,211,252,.3);
  border-top-color:#22c55e;
  border-radius:50%;
  animation:spin 1s linear infinite;
  margin:0 auto 10px;
}
@keyframes spin{to{transform:rotate(360deg)}}

/* 유닛 렌더 */
.unit{
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:4px;
  line-height:1;
}
.unit-img{
  max-width:80%;
  max-height:60%;
  object-fit:contain;
  pointer-events:none;
  image-rendering:auto;
}
.unit-name{font-size:11px}
.unit-name.cd{color:var(--muted)} /* 직전 턴 사용으로 이번 턴 사용 불가 표시 */
.hpbar{
  display:flex;
  gap:2px;
}
.hpseg{
  width:8px;
  height:4px;
  background:#bbf7d0;
  border-radius:999px;
  border:1px solid #86efac;
}
.hpseg.on{
  background:var(--ok);
  border-color:#22c55e;
}

/* 공격 이펙트 이미지 */
.hit-effect{
  position:absolute;
  inset:0;
  margin:auto;
  width:90%;
  height:90%;
  object-fit:contain;
  pointer-events:none;
  animation:hit-burst .45s ease-out forwards;
}
@keyframes hit-burst{
  0%{opacity:0;transform:scale(.4);}
  25%{opacity:1;transform:scale(1);}
  100%{opacity:0;transform:scale(1.3);}
}

/* =========================
   NEW: 중앙 안내 패널 UX 개선
   ========================= */
.guide-title{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
}
.guide-title b{
  font-size:14px;
  color:#0f172a;
}
.guide-tag{
  font-size:11px;
  padding:4px 8px;
  border-radius:999px;
  border:1px solid #bbf7d0;
  background:#ecfdf5;
  color:#166534;
  white-space:nowrap;
}
.guide-body{
  margin-top:8px;
  font-size:13px;
  line-height:1.55;
  color:#0f172a;
}
.guide-body ul{
  margin:8px 0 0 18px;
  padding:0;
}
.guide-body li{
  margin:6px 0;
}
.guide-dim{
  color:#334155;
}
.guide-em{
  font-weight:700;
  color:#166534;
}

/* =========================
   Mobile Landscape Optimization (추가)
   - PC는 영향 없음: pointer: coarse(터치) + landscape + max-width 조건
   ========================= */
.board, .cell, .chip, .btn{ touch-action: manipulation; }

/* 세로모드 안내 오버레이(추가) */
#rotateOverlay{
  position:fixed;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  background:rgba(15,23,42,.45);
  z-index:9999;
}
#rotateOverlay .box{
  background:#fffef7;
  border:1px solid #e2e8f0;
  border-radius:20px;
  padding:18px 18px 14px;
  text-align:center;
  width:min(92vw, 360px);
  box-shadow:0 18px 40px rgba(15,23,42,.3);
}
#rotateOverlay .box b{display:block;margin-bottom:6px;color:#111827}
#rotateOverlay .box small{color:#64748b}

/* 안드로이드 모바일 가로모드에서 보드 크기 확보 */
@media (max-width: 1024px) and (orientation: landscape) and (pointer: coarse){
  .wrap{
    max-width:100%;
    margin:10px auto;
    padding:14px 14px 12px;
    border-radius:18px;
  }
  .topbar{
    flex-wrap:wrap;
    gap:8px;
    padding:4px 2px 8px;
  }
  .pill.status{min-width:140px}
  .btn{padding:10px 14px;border-radius:16px}

  /* 보드 2개를 위, 중앙 패널을 아래로 내려서 보드 영역 확대 */
  .boards{
    grid-template-columns:1fr 1fr;
    grid-template-areas:
      "me ai"
      "zone zone";
    gap:12px;
  }
  .boards > div:nth-child(1){ grid-area:me; }
  .boards > div:nth-child(2){ grid-area:zone; }
  .boards > div:nth-child(3){ grid-area:ai; }

  /* 핵심: 화면 높이를 적극 사용 (가로모드) */
  .board{
    width:min(46vw, 76vh);
    max-width:520px;
    margin:0 auto;
    padding:10px;
    border-radius:18px;
  }

  .cell{ font-size:12px; border-radius:7px; }
  .unit-name{font-size:11px}
  .hpseg{ width:10px; height:5px; }

  .zone{ gap:10px; }
  .panel{ border-radius:16px; }

  /* 리저브는 가로모드에서 4열 */
  .reserve{
    grid-template-columns:repeat(4, 1fr);
    gap:8px;
  }
  .chip{ padding:10px 10px; border-radius:14px; font-size:13px; }

  /* 로그는 공간 절약 */
  .log{ height:92px; margin-top:12px; }
}
</style>
</head>
<body>
<!-- 오버레이들 -->
<div class="overlay" id="overlay">
  <div class="start">
    <h1>게임 시작</h1>
    <p><small>버튼을 누르면 진영이 배정됩니다.</small></p>
    <button class="btn" id="btnStart">게임 시작</button>
  </div>
</div>
<div class="overlay" id="aiOverlay" style="display:none">
  <div class="start">
    <div class="spinner"></div>
    <h1>상대 턴</h1>
    <p><small>처리 중…</small></p>
  </div>
</div>
<div class="overlay" id="nextOverlay" style="display:none">
  <div class="start">
    <h1>다음 턴</h1>
    <p><small>공격 단계로 전환</small></p>
  </div>
</div>
<div class="overlay" id="resultOverlay" style="display:none">
  <div class="start" id="resultBox" style="text-align:center;">
    <h1>게임 종료</h1>
    <div id="resultContent" style="margin:12px 0;font-size:14px;line-height:1.6"></div>
    <button class="btn" id="btnRestart">게임 다시 시작</button>
  </div>
</div>

<!-- (추가) 모바일 세로모드일 때 가로 회전 안내 -->
<div id="rotateOverlay">
  <div class="box">
    <b>가로 모드로 플레이해주세요</b>
    <small>안드로이드 기준, 화면을 가로로 회전하면 보드가 크게 표시됩니다.</small>
  </div>
</div>

<div class="wrap">
  <div class="topbar">
    <button class="btn" id="btnReady">준비 종료</button>
    <div class="pill status"><span id="phase">대기</span> · <span id="timer">00</span>s</div>
    <div class="pill">턴 <span id="turn">1</span>/<span id="turnTotal">3</span></div>
    <div class="pill">내 진영 <span id="myFaction" class="badge">-</span></div>
    <div class="pill">상대 진영 <span id="aiFaction" class="badge">-</span></div>
    <div style="flex:1"></div>
    <button class="btn" id="btnReset">초기화</button>
    <button class="btn btn-danger" id="btnSurrender">항복</button>
  </div>

  <div class="boards">
    <div>
      <div class="center" style="margin-bottom:6px;font-weight:600;">플레이어 보드</div>
      <div class="board" id="boardMe"></div>
    </div>

    <div class="zone">
      <div class="panel">
        <div class="row" style="justify-content:space-between">
          <div><b>기물 카테고리</b> <small id="reserveInfo">(남은 0/8)</small></div>
          <div class="pill"><small>배치/이동: 클릭 → 빈칸</small></div>
        </div>
        <div class="reserve" id="reserve"></div>
      </div>

      <!-- =========================
           NEW: 준비/공격 단계별 안내 패널
           ========================= -->
      <div class="panel" id="guidePanel">
        <div class="guide-title">
          <b id="guideTitle">안내</b>
          <span class="guide-tag" id="guideTag">대기</span>
        </div>
        <div class="guide-body" id="guideBody"></div>
      </div>
    </div>

    <div>
      <div class="center" style="margin-bottom:6px;font-weight:600;">적 보드</div>
      <div class="board" id="boardAI"></div>
    </div>
  </div>

  <div class="log" id="log"></div>
</div>

<script>
/* ===== 상수 ===== */
const BOARD_SIZE=5, PREP_TIME=20, ATTACK_TIME=8, MAX_TURN=10, AI_TURN_DELAY=1000;

/* ===== 데이터 ===== */
const FACTIONS={
  "수인":["디아나","티그","루포","버터","코미","베니","베니","베니"],
  "요정":["에르핀","네르","죠안","에슈르","마요(멋짐)","마리","마리","마리"],
  "마녀":["벨리타","프리클","셰럼","마카샤","포셔","레비","레비","레비"]
};
const PATTERNS={
  "디아나":"plus1","티그":"diag1","루포":"cross2","버터":"square1","코미":"line2","베니":"plus1",
  "에르핀":"diag1","네르":"cross2","죠안":"plus1","에슈르":"line2","마요(멋짐)":"square1","마리":"plus1",
  "벨리타":"line2","프리클":"diag1","셰럼":"plus1","마카샤":"cross2","포셔":"square1","레비":"plus1"
};
const HP_TABLE={
  "디아나":3,"버터":2,"티그":2,"루포":2,"코미":2,"베니":1,
  "벨리타":3,"프리클":2,"마카샤":2,"셰럼":2,"포셔":2,"레비":1,
  "에르핀":3,"네르":2,"죠안":2,"에슈르":2,"마요(멋짐)":2,"마리":1
};

/* ===== 유닛 이미지 경로 매핑 (실제 PNG 경로에 맞게 수정) ===== */
const UNIT_IMAGES = {
  "디아나":"img/디아나.png",
  "티그":"img/티그.png",
  "루포":"img/루포.png",
  "버터":"img/버터.png",
  "코미":"img/코미.png",
  "베니":"img/베니.png",
  "에르핀":"img/에르핀.png",
  "네르":"img/네르.png",
  "죠안":"img/죠안.png",
  "에슈르":"img/에슈르.png",
  "마요(멋짐)":"img/마요(멋짐).png",
  "마리":"img/마리.png",
  "벨리타":"img/벨리타.png",
  "프리클":"img/프리클.png",
  "셰럼":"img/셰럼.png",
  "마카샤":"img/마카샤.png",
  "포셔":"img/포셔.png",
  "레비":"img/레비.png"
};
function getUnitImage(name){
  return UNIT_IMAGES[name] || "img/default.png";
}

/* ===== 공격 이펙트 이미지 매핑 ===== */
const EFFECT_IMAGES = {
  "디아나":"img/diana_attack.png",
  "티그":"img/tig_attack.png",
  "루포":"img/rupo_attack.png",
  "버터":"img/butter_attack.png",
  "코미":"img/komi_attack.png",
  "베니":"img/benny_attack.png",
  "에르핀":"img/erfin_attack.png",
  "네르":"img/ner_attack.png",
  "죠안":"img/joan_attack.png",
  "에슈르":"img/eshur_attack.png",
  "마요(멋짐)":"img/mayo_cool_attack.png",
  "마리":"img/marie_attack.png",
  "벨리타":"img/velita_attack.png",
  "프리클":"img/prickle_attack.png",
  "셰럼":"img/sherm_attack.png",
  "마카샤":"img/makasha_attack.png",
  "포셔":"img/posher_attack.png",
  "레비":"img/levi_attack.png"
};
function getEffectImage(name){
  return EFFECT_IMAGES[name] || "img/default_attack.png";
}

/* ===== 점수 규칙 ===== */
const SCORE_TABLE = {
  "디아나":3, "에르핀":3, "벨리타":3,
  "티그":2, "네르":2, "프리클":2, "루포":2, "마카샤":2, "죠안":2, "셰럼":2, "에슈르":2, "포셔":2, "마요(멋짐)":2,
  "버터":1, "코미":1, "베니":1, "마리":1, "레비":1
};
function calcScore(board){
  let pieces=0, score=0;
  for(let r=0;r<BOARD_SIZE;r++) for(let c=0;c<BOARD_SIZE;c++){
    const u=board[r][c];
    if(u){
      pieces++;
      score += SCORE_TABLE[u.name] || 0;
    }
  }
  return {pieces,score};
}

/* ===== 왕 정의 ===== */
const KINGS = ["디아나", "에르핀", "벨리타"];
function hasKing(board){
  for(let r=0;r<BOARD_SIZE;r++) for(let c=0;c<BOARD_SIZE;c++){
    if(board[r][c] && KINGS.includes(board[r][c].name)) return true;
  }
  return false;
}

/* ===== 상태 ===== */
let myFaction=null, aiFaction=null;
let turn=1, phase="대기";
let timerId=null, timeLeft=0;

const me=Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(null));
const ai=Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(null));
let reserve=[], selectedReserve=null, pickUp=null;
let attackChoice=null, lastPreview=null, aiUnits=[], hasAttacked=false;

/* 플레이어가 때린 적 보드의 영구 상태: none / hit / kill */
const aiCellState = Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill("none"));

/* ===== 유틸 ===== */
const elBoardMe=document.getElementById('boardMe');
const elBoardAI=document.getElementById('boardAI');
const elReserve=document.getElementById('reserve');
const elAiOverlay=document.getElementById('aiOverlay');
const elNextOverlay=document.getElementById('nextOverlay');

/* NEW: 안내 패널 DOM */
const elGuideTitle = document.getElementById('guideTitle');
const elGuideBody  = document.getElementById('guideBody');
const elGuideTag   = document.getElementById('guideTag');

for(let i=0;i<BOARD_SIZE*BOARD_SIZE;i++){
  const d=document.createElement('div');
  d.className='cell';
  d.dataset.idx=i;
  elBoardMe.appendChild(d);
}
for(let i=0;i<BOARD_SIZE*BOARD_SIZE;i++){
  const d=document.createElement('div');
  d.className='cell';
  d.dataset.idx=i;
  elBoardAI.appendChild(d);
}

function fmtTime(n){return String(n).padStart(2,'0')}
function log(msg){
  const el=document.getElementById('log');
  const t=new Date().toLocaleTimeString();
  el.innerHTML=`[${t}] ${msg}<br>`+el.innerHTML;
}
const delay=ms=>new Promise(r=>setTimeout(r,ms));
const nextFrame=()=>new Promise(r=>requestAnimationFrame(()=>r()));

/* =========================
   NEW: 단계별 안내 패널 업데이트
   ========================= */
function updateGuidePanel(){
  // 준비 단계 문구
  const prepHTML = `
    <div class="guide-dim">
      <span class="guide-em">기물을 보드에 배치해보세요!</span><br>
      기물 카테고리에 있는 기물을 클릭한 뒤, 플레이어 보드를 클릭하면 기물이 배치됩니다!
    </div>
  `;

  // 공격 단계 문구
  const attackHTML = `
    <div class="guide-dim"><span class="guide-em">[공격 방법!]</span></div>
    <ul>
      <li>기물을 클릭합니다! 그리고 상대 보드 칸을 클릭하면 공격이 진행됩니다!</li>
      <li>이전 턴에 사용한 기물은 1턴이 지나기까지 다시 사용할 수 없습니다 ㅠㅠ</li>
      <li>공격이 적중하면 상대 보드가 붉게 표시됩니다!</li>
      <li>상대 기물을 격파하면 보드 위에 X표시가 됩니다!</li>
      <li>공격을 못해도 걱정하지마세요! 자동으로 공격이 진행됩니다!</li>
      <li>상대 왕을 잡아서 게임에서 승리하세요!</li>
    </ul>
  `;

  if(phase === "준비"){
    elGuideTitle.textContent = "배치 안내";
    elGuideTag.textContent = "준비 단계";
    elGuideBody.innerHTML = prepHTML;
    return;
  }

  // 준비가 끝나면(공격/전투/상대턴/다음턴 등) 공격 안내를 기본으로 유지
  if(["공격","전투","상대턴"].includes(phase)){
    elGuideTitle.textContent = "공격 안내";
    elGuideTag.textContent = (phase === "공격") ? "공격 단계" : "진행 중";
    elGuideBody.innerHTML = attackHTML;
    return;
  }

  // 기타 단계(대기/진영배정/종료)에서는 상황 안내
  elGuideTitle.textContent = "안내";
  elGuideTag.textContent = phase;
  elGuideBody.innerHTML = `
    <div class="guide-dim">
      현재 단계: <span class="guide-em">${phase}</span><br>
      게임을 시작하면 준비 단계 안내가 표시됩니다.
    </div>
  `;
}

/* ===== 렌더 ===== */
function renderBoards(){
  const cellsMe=elBoardMe.children;
  for(let i=0;i<BOARD_SIZE*BOARD_SIZE;i++){
    const r=Math.floor(i/BOARD_SIZE), c=i%BOARD_SIZE;
    const v=me[r][c], el=cellsMe[i];
    el.classList.remove('preview');
    renderCell(el, v, true, v ? (turn>1 && v.lastUsedTurn===turn-1) : false);
  }

  const cellsAI=elBoardAI.children;
  for(let i=0;i<BOARD_SIZE*BOARD_SIZE;i++){
    const r=Math.floor(i/BOARD_SIZE), c=i%BOARD_SIZE;
    const el=cellsAI[i];
    el.classList.remove('preview','hit','kill');
    el.innerHTML="";
    el.title="";
    const state = aiCellState[r][c];
    if(state==="hit") el.classList.add('hit');
    if(state==="kill"){
      el.classList.add('kill');
      el.innerHTML = '<span class="kill-x">X</span>';
    }
  }
  if(lastPreview){ previewOn(lastPreview.r,lastPreview.c,true); }
}

function renderCell(el, unit, showHp, cd){
  if(!unit){
    if(!el.classList.contains('kill')){
      el.innerHTML="";
      el.title="";
    }
    return;
  }
  const {name,hp,max}=unit;

  if(showHp){
    const imgSrc = getUnitImage(name);
    el.innerHTML = `
      <div class="unit">
        <img class="unit-img" src="${imgSrc}" alt="${name}">
        <div class="hpbar">
          ${Array.from({length:max},(_,i)=>`<div class="hpseg ${i<hp?'on':''}"></div>`).join('')}
        </div>
      </div>
    `;
  }else{
    el.innerHTML = name;
  }
  el.title = `${name} HP ${hp}/${max}`;
}

/* 상태/타이머 */
function setPhase(p, seconds=0){
  phase=p;
  document.getElementById('phase').textContent=p;

  // NEW: 단계 변경될 때 안내 패널도 동기화
  updateGuidePanel();

  clearInterval(timerId);
  timeLeft=seconds;
  document.getElementById('timer').textContent=fmtTime(timeLeft);
  if(seconds>0){
    timerId=setInterval(()=>{
      timeLeft--;
      document.getElementById('timer').textContent=fmtTime(timeLeft);
      if(timeLeft<=0){
        clearInterval(timerId);
        onTimerEnd();
      }
    },1000);
  }
}

/* ===== 흐릿표시 초기화 ===== */
function clearEnemyMarks(){
  [...elBoardAI.children].forEach(el=>el.classList.remove('preview'));
}
function clearMyMarks(){
  [...elBoardMe.children].forEach(el=>el.classList.remove('preview','hit','kill'));
}

/* ===== 유닛 ===== */
function createUnit(name){
  const max=HP_TABLE[name]||1;
  return {name, hp:max, max, lastUsedTurn:-1};
}

/* ===== 단계 전환 타이머 ===== */
function onTimerEnd(){
  if(phase==="준비") finishPrepare();
  else if(phase==="공격") autoAttackIfNone();
}

/* ===== 진영 배정 → 준비 ===== */
function assignFactions(){
  const keys=Object.keys(FACTIONS);
  myFaction=keys[Math.floor(Math.random()*keys.length)];
  document.getElementById('myFaction').textContent=myFaction;
  log(`내 진영 배정: ${myFaction}`);
  setTimeout(()=>{
    const others=keys.filter(k=>k!==myFaction);
    aiFaction=others[Math.floor(Math.random()*others.length)];
    document.getElementById('aiFaction').textContent=aiFaction;
    log(`상대 진영 배정: ${aiFaction}`);
    startPrepare();
  },800);
}
function startPrepare(){
  for(let r=0;r<BOARD_SIZE;r++) for(let c=0;c<BOARD_SIZE;c++) me[r][c]=null;
  reserve=[...FACTIONS[myFaction]].sort((a,b)=>a.localeCompare(b));
  selectedReserve=null;
  pickUp=null;
  attackChoice=null;
  lastPreview=null;
  for(let r=0;r<BOARD_SIZE;r++) for(let c=0;c<BOARD_SIZE;c++){
    ai[r][c]=null;
    aiCellState[r][c]="none";
  }
  aiRandomFill();
  renderReserve();
  renderBoards();
  setPhase("준비", PREP_TIME);
  log("준비 단계 시작. 배치 후 [준비 종료].");
}
function renderReserve(){
  elReserve.innerHTML="";
  reserve.forEach((name,idx)=>{
    const d=document.createElement('div');
    d.className='chip'+(selectedReserve===idx?' sel':'');

    d.textContent=name;
    d.title=`패턴:${PATTERNS[name]} · HP ${HP_TABLE[name]}`;

    d.onclick=()=>{
      selectedReserve = (selectedReserve===idx? null: idx);
      pickUp=null;
      renderReserve();
    };
    elReserve.appendChild(d);
  });
  document.getElementById('reserveInfo').textContent=`(남은 ${reserve.length}/8)`;
}
function finishPrepare(){
  while(reserve.length){
    const name=reserve.shift();
    const empty=[];
    for(let r=0;r<BOARD_SIZE;r++) for(let c=0;c<BOARD_SIZE;c++) if(!me[r][c]) empty.push({r,c});
    if(!empty.length) break;
    const {r,c}=empty[Math.floor(Math.random()*empty.length)];
    me[r][c]=createUnit(name);
  }
  renderReserve();
  renderBoards();
  log("준비 단계 종료.");
  startAttack();
}
function aiRandomFill(){
  for(let r=0;r<BOARD_SIZE;r++) for(let c=0;c<BOARD_SIZE;c++) if(!ai[r][c]) ai[r][c]=null;
  const pool=[...FACTIONS[aiFaction]];
  while(pool.length){
    const name=pool.shift();
    const empty=[];
    for(let r=0;r<BOARD_SIZE;r++) for(let c=0;c<BOARD_SIZE;c++) if(!ai[r][c]) empty.push({r,c});
    if(!empty.length) break;
    const {r,c}=empty[Math.floor(Math.random()*empty.length)];
    ai[r][c]=createUnit(name);
  }
  collectAiUnits();
}
function collectAiUnits(){
  aiUnits=[];
  for(let r=0;r<BOARD_SIZE;r++) for(let c=0;c<BOARD_SIZE;c++) if(ai[r][c]){
    aiUnits.push({r,c,name:ai[r][c].name,lastUsedTurn:ai[r][c].lastUsedTurn});
  }
}

/* ===== 공격 단계 ===== */
function startAttack(){
  hasAttacked=false;
  setPhase("공격", ATTACK_TIME);
  attackChoice=null;
  lastPreview=null;
  clearEnemyMarks();
  clearMyMarks();
  renderBoards();
  log(`공격 단계 시작. 턴 ${turn}. 한 턴에 한 기물만 공격.`);
}
function selectableMyUnits(){
  const list=[];
  for(let r=0;r<BOARD_SIZE;r++) for(let c=0;c<BOARD_SIZE;c++){
    const u=me[r][c];
    if(u && u.hp>0 && (turn===1 || u.lastUsedTurn!==turn-1)) list.push({r,c,name:u.name});
  }
  return list;
}
function autoAttackIfNone(){
  if(attackChoice){ beginBattle(); return; }
  const list=selectableMyUnits();
  if(!list.length){
    log("사용 가능한 기물이 없어 공격을 건너뜁니다.");
    beginBattle();
    return;
  }
  hasAttacked=true;
  const unit=list[Math.floor(Math.random()*list.length)];
  const target={r:Math.floor(Math.random()*BOARD_SIZE), c:Math.floor(Math.random()*BOARD_SIZE)};
  attackChoice={unitAt:unit, target};
  log(`시간 초과. 랜덤 공격: ${unit.name} → (${target.r+1},${target.c+1})`);
  beginBattle();
}

/* ===== 전투 처리 ===== */
function patternOffsets(k){
  switch(k){
    case "plus1": return [[1,0],[-1,0],[0,1],[0,-1]];
    case "diag1": return [[1,1],[1,-1],[-1,1],[-1,-1]];
    case "cross2": return [[1,0],[-1,0],[0,1],[0,-1],[2,0],[-2,0],[0,2],[0,-2]];
    case "square1": return [[0,0],[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
    case "line2": return [[1,0],[2,0],[-1,0],[-2,0],[0,1],[0,2],[0,-1],[0,-2]];
    default: return [[0,0]];
  }
}

/* 플레이어 공격 이펙트 출력 */
function spawnHitEffect(el, attackerName){
  const src = getEffectImage(attackerName);
  const img = document.createElement('img');
  img.src = src;
  img.alt = attackerName + " 공격";
  img.className = 'hit-effect';
  el.appendChild(img);
  setTimeout(()=>{ img.remove(); }, 500);
}

function applyAttack(boardEl, boardData, attackerName, target){
  const pattern=PATTERNS[attackerName]||"plus1";
  const ofs=patternOffsets(pattern);
  const isPlayerAttackOnAI = (boardEl===elBoardAI && boardData===ai);
  let hits=0,kills=0;

  ofs.forEach(([dr,dc])=>{
    const rr=target.r+dr, cc=target.c+dc;
    if(rr<0||cc<0||rr>=BOARD_SIZE||cc>=BOARD_SIZE) return;
    const idx=rr*BOARD_SIZE+cc, el=boardEl.children[idx];

    const hadUnit = !!boardData[rr][cc];

    el.classList.add('hit');

    if(boardData[rr][cc]){
      boardData[rr][cc].hp -= 1;
      if(boardData[rr][cc].hp<=0){
        boardData[rr][cc]=null;
        kills++;
        el.classList.add('kill');
        if(boardEl===elBoardMe){
          el.innerHTML="";
          el.title="";
        }
        if(isPlayerAttackOnAI && hadUnit){
          aiCellState[rr][cc]="kill";
          spawnHitEffect(el, attackerName);
        }
      }else{
        if(boardEl===elBoardMe){
          renderCell(el, boardData[rr][cc], true, (turn>1 && boardData[rr][cc].lastUsedTurn===turn-1));
        }
        if(isPlayerAttackOnAI && hadUnit){
          aiCellState[rr][cc]="hit";
          spawnHitEffect(el, attackerName);
        }
      }
    }
    hits++;
  });

  if(isPlayerAttackOnAI){
    renderBoards();
  }
  return {pattern,hits,kills};
}
function beginBattle(){
  setPhase("전투");
  if(attackChoice){
    const {unitAt,target}=attackChoice;
    const myUnit=me[unitAt.r][unitAt.c];
    if(myUnit){
      myUnit.lastUsedTurn = turn;
      const res=applyAttack(elBoardAI, ai, myUnit.name, target);
      collectAiUnits();
      log(`전투: ${myUnit.name} 패턴[${res.pattern}] 타격 ${res.hits}, 격파 ${res.kills}.`);
    }
  }else{
    log("공격 없음.");
  }
  if(!hasKing(ai)){
    log("승리: 상대 왕이 사망했습니다.");
    setPhase("종료");
    showResultPopup();
    return;
  }
  enemyCounterAndEnd();
}

/* ===== AI 반격 + 턴 종료 ===== */
async function enemyCounterAndEnd(){
  const able = aiUnits.filter(u => (turn===1 || u.lastUsedTurn!==turn-1));
  if(able.length>0){
    setPhase("상대턴");
    elAiOverlay.style.display='flex';
    await nextFrame();
    await delay(AI_TURN_DELAY);
    clearMyMarks();
    const aiUnit=able[Math.floor(Math.random()*able.length)];
    const targetMe={r:Math.floor(Math.random()*BOARD_SIZE), c:Math.floor(Math.random()*BOARD_SIZE)};
    const res2=applyAttack(elBoardMe, me, aiUnit.name, targetMe);
    if(ai[aiUnit.r][aiUnit.c]) ai[aiUnit.r][aiUnit.c].lastUsedTurn = turn;
    log(`적 반격: ${aiUnit.name} 타격 ${res2.hits}, 격파 ${res2.kills}.`);
    elAiOverlay.style.display='none';
  }else{
    log("상대는 이번 턴에 사용할 기물이 없음.");
  }
  if(!hasKing(me)){
    log("패배: 아군 왕이 사망했습니다.");
    setPhase("종료");
    showResultPopup();
    return;
  }
  if(countUnits(ai)===0 || countUnits(me)===0){
    setPhase("종료");
    showResultPopup();
    return;
  }
  endTurn();
}
function countUnits(board){
  let n=0;
  for(let r=0;r<BOARD_SIZE;r++) for(let c=0;c<BOARD_SIZE;c++) if(board[r][c]) n++;
  return n;
}
async function endTurn(){
  if(turn >= MAX_TURN){
    setPhase("종료");
    showResultPopup();
    return;
  }
  turn++;
  document.getElementById('turn').textContent=turn;
  elNextOverlay.style.display='flex';
  await nextFrame();
  await delay(600);
  elNextOverlay.style.display='none';
  startAttack();
}

/* ===== 상호작용 ===== */
elBoardMe.addEventListener('click', (e)=>{
  const cell=e.target.closest('.cell');
  if(!cell) return;
  const idx=+cell.dataset.idx;
  const r=Math.floor(idx/BOARD_SIZE), c=idx%BOARD_SIZE;

  if(phase==="준비"){
    if(selectedReserve!=null && !me[r][c]){
      const name=reserve.splice(selectedReserve,1)[0];
      selectedReserve=null;
      me[r][c]=createUnit(name);
      renderReserve();
      renderBoards();
    }else if(me[r][c] && !pickUp){
      pickUp={r,c};
    }else if(pickUp){
      if(!me[r][c]){
        me[r][c]=me[pickUp.r][pickUp.c];
        me[pickUp.r][pickUp.c]=null;
      }
      pickUp=null;
      renderBoards();
    }
  }else if(phase==="공격"){
    if(hasAttacked) return;
    if(attackChoice && attackChoice.unitAt) return;
    const u=me[r][c];
    if(!u) return;
    if(turn>1 && u.lastUsedTurn===turn-1){
      log("직전 턴에 사용한 기물은 이번 턴에 사용할 수 없습니다.");
      return;
    }
    attackChoice={unitAt:{r,c,name:u.name}, target:null};
    log(`선택: ${u.name} (내 보드 ${r+1},${c+1})`);
  }
});

elBoardAI.addEventListener('click', (e)=>{
  if(phase!=="공격" || hasAttacked || !attackChoice || !attackChoice.unitAt) return;
  const cell=e.target.closest('.cell');
  if(!cell) return;
  const idx=+cell.dataset.idx;
  const r=Math.floor(idx/BOARD_SIZE), c=idx%BOARD_SIZE;

  if(lastPreview && lastPreview.r===r && lastPreview.c===c){
    hasAttacked=true;
    attackChoice.target={r,c};
    log(`공격 확정: (${r+1},${c+1})`);
    beginBattle();
    return;
  }
  previewOn(r,c,false);
});

function previewOn(r,c,keep=false){
  clearEnemyMarks();
  lastPreview={r,c};
  const name = me[attackChoice.unitAt.r][attackChoice.unitAt.c].name;
  const pattern = PATTERNS[name]||"plus1";
  const ofs = patternOffsets(pattern);
  ofs.forEach(([dr,dc])=>{
    const rr=r+dr, cc=c+dc;
    if(rr<0||cc<0||rr>=BOARD_SIZE||cc>=BOARD_SIZE) return;
    elBoardAI.children[rr*BOARD_SIZE+cc].classList.add('preview');
  });
  if(!keep) log(`미리보기: (${r+1},${c+1}), 패턴[${pattern}]`);
}

/* ===== 결과 ===== */
function showResultPopup(){
  const myRes = calcScore(me);
  const aiRes = calcScore(ai);
  let winner = "무승부";
  if(myRes.score > aiRes.score) winner="플레이어 승";
  else if(myRes.score < aiRes.score) winner="AI 승";

  const html = `
    <p>플레이어 남은 기물: <b>${myRes.pieces}</b>개 (${myRes.score}점)</p>
    <p>상대 남은 기물: <b>${aiRes.pieces}</b>개 (${aiRes.score}점)</p>
    <hr style="border:none;border-top:1px solid #e2e8d0;margin:8px 0;">
    <p><b>결과: ${winner}</b></p>
  `;
  document.getElementById('resultContent').innerHTML = html;
  document.getElementById('resultOverlay').style.display='flex';
}
document.getElementById('btnRestart').onclick=()=>{ location.reload(); };

/* ===== 버튼 ===== */
document.getElementById('btnStart').onclick=()=>{
  document.getElementById('overlay').style.display='none';
  document.getElementById('turnTotal').textContent=MAX_TURN;
  setPhase("진영배정");
  assignFactions();
};
document.getElementById('btnReady').onclick=()=>{ if(phase==="준비") finishPrepare(); };
document.getElementById('btnReset').onclick=()=>{ location.reload(); };
document.getElementById('btnSurrender').onclick=()=>{
  setPhase("종료");
  log("항복. 패배 처리.");
};

/* ===== (추가) 모바일 세로모드 회전 안내 ===== */
const rotateOverlay = document.getElementById('rotateOverlay');
function isTouchDevice(){
  return window.matchMedia && window.matchMedia("(pointer: coarse)").matches;
}
function updateRotateOverlay(){
  const portrait = window.matchMedia("(orientation: portrait)").matches;
  if(isTouchDevice() && portrait){
    rotateOverlay.style.display = "flex";
  }else{
    rotateOverlay.style.display = "none";
  }
}
window.addEventListener("resize", updateRotateOverlay);
window.addEventListener("orientationchange", updateRotateOverlay);
updateRotateOverlay();

/* ===== 초기 렌더 ===== */
renderBoards();
renderReserve();
updateGuidePanel(); // NEW: 최초 안내 렌더
</script>
</body>
</html>
