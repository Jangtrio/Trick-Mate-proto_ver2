<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Trick Mate 프로토타입</title>
<style>
:root{--bg:#0f1115;--panel:#171a21;--panel2:#1f2430;--line:#2b3242;--text:#e6e9ef;--muted:#9aa3b2;--accent:#7cd1ff;--danger:#ff6b6b;--ok:#78e08f}
*{box-sizing:border-box;font-family:system-ui,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,sans-serif}
body{margin:0;background:var(--bg);color:var(--text)}
.wrap{max-width:1200px;margin:20px auto;padding:12px}
.topbar{display:flex;gap:8px;align-items:center;background:var(--panel);border:1px solid var(--line);padding:10px;border-radius:10px;position:sticky;top:8px;z-index:2}
.btn{background:var(--panel2);border:1px solid var(--line);color:var(--text);padding:8px 12px;border-radius:10px;cursor:pointer;user-select:none}
.btn[disabled]{opacity:.5;cursor:not-allowed}
.btn-danger{border-color:#5a2931;background:#2a0f13;color:#ffb4b4}
.pill{padding:6px 10px;border-radius:999px;background:#101521;border:1px solid var(--line);font-weight:600}
.boards{display:grid;grid-template-columns:1fr 320px 1fr;gap:12px;margin-top:12px}
.board{display:grid;grid-template-columns:repeat(5,1fr);aspect-ratio:1;background:var(--panel);border:1px solid var(--line);border-radius:10px;overflow:hidden}
.cell{border:1px solid #232838;display:flex;align-items:center;justify-content:center;font-weight:700;position:relative;font-size:12px;padding:2px;text-align:center}
.cell:hover{outline:2px solid rgba(124,209,255,.25);outline-offset:-2px;cursor:pointer}
.cell.preview::after{content:"";position:absolute;inset:0;background:rgba(124,209,255,.18)}
.cell.hit{background:rgba(255,107,107,.22)}
.cell.kill{background:rgba(255,107,107,.35)}
.zone{display:flex;flex-direction:column;gap:12px}
.panel{background:var(--panel);border:1px solid var(--line);border-radius:10px;padding:12px}
.reserve{display:grid;grid-template-columns:repeat(4,1fr);gap:8px}
.chip{padding:8px;border-radius:10px;border:1px solid var(--line);text-align:center;background:var(--panel2);cursor:pointer;user-select:none}
.chip.sel{outline:2px solid var(--accent)}
.log{height:120px;overflow:auto;background:var(--panel);border:1px solid var(--line);border-radius:10px;padding:10px;margin-top:12px;font-size:14px}
.row{display:flex;gap:12px;align-items:center}
.center{display:flex;align-items:center;justify-content:center}
.overlay{position:fixed;inset:0;background:rgba(0,0,0,.65);display:flex;align-items:center;justify-content:center;z-index:5}
.overlay .start{background:#0b1320;border:1px solid #1c2a40;border-radius:18px;padding:28px 32px;box-shadow:0 10px 30px rgba(0,0,0,.4);text-align:center;min-width:260px}
.overlay .start h1{margin:0 0 8px 0}
.badge{display:inline-block;padding:4px 8px;border:1px solid var(--line);border-radius:8px;background:#141925;margin-left:6px}
.status{min-width:120px;text-align:center}
small{color:var(--muted)}
.spinner{width:36px;height:36px;border:3px solid rgba(124,209,255,.2);border-top-color:var(--accent);border-radius:50%;animation:spin 1s linear infinite;margin:0 auto 8px}
@keyframes spin{to{transform:rotate(360deg)}}

/* 유닛 렌더 */
.unit{display:flex;flex-direction:column;align-items:center;gap:4px;line-height:1}
.unit-img{
  width:90%;
  max-height:56px;
  object-fit:contain;
  image-rendering:auto;
  pointer-events:none;
}
.unit-name{font-size:11px}
.unit-name.cd{color:var(--muted)} /* 직전 턴 사용으로 이번 턴 사용 불가 */
.hpbar{display:flex;gap:2px}
.hpseg{width:8px;height:4px;background:#233b2b;border-radius:2px;border:1px solid #2d4a36}
.hpseg.on{background:var(--ok);border-color:#3a7a52}
</style>
</head>
<body>
<!-- 오버레이들 -->
<div class="overlay" id="overlay">
  <div class="start">
    <h1>게임 시작</h1>
    <p><small>버튼을 누르면 진영이 배정됩니다.</small></p>
    <button class="btn" id="btnStart">게임 시작</button>
  </div>
</div>
<div class="overlay" id="aiOverlay" style="display:none">
  <div class="start">
    <div class="spinner"></div>
    <h1>상대 턴</h1>
    <p><small>처리 중…</small></p>
  </div>
</div>
<div class="overlay" id="nextOverlay" style="display:none">
  <div class="start">
    <h1>다음 턴</h1>
    <p><small>공격 단계로 전환</small></p>
  </div>
</div>
<div class="overlay" id="resultOverlay" style="display:none">
  <div class="start" id="resultBox" style="text-align:center;">
    <h1>게임 종료</h1>
    <div id="resultContent" style="margin:12px 0;font-size:14px;line-height:1.6"></div>
    <button class="btn" id="btnRestart">게임 다시 시작</button>
  </div>
</div>

<div class="wrap">
  <div class="topbar">
    <button class="btn" id="btnReady">준비 종료</button>
    <div class="pill status"><span id="phase">대기</span> · <span id="timer">00</span>s</div>
    <div class="pill">턴 <span id="turn">1</span>/<span id="turnTotal">3</span></div>
    <div class="pill">내 진영 <span id="myFaction" class="badge">-</span></div>
    <div class="pill">상대 진영 <span id="aiFaction" class="badge">-</span></div>
    <div style="flex:1"></div>
    <button class="btn" id="btnReset">초기화</button>
    <button class="btn btn-danger" id="btnSurrender">항복</button>
  </div>

  <div class="boards">
    <div>
      <div class="center" style="margin-bottom:6px;">플레이어 보드</div>
      <div class="board" id="boardMe"></div>
    </div>

    <div class="zone">
      <div class="panel">
        <div class="row" style="justify-content:space-between">
          <div><b>기물 카테고리</b> <small id="reserveInfo">(남은 0/8)</small></div>
          <div class="pill"><small>배치/이동: 클릭 → 빈칸</small></div>
        </div>
        <div class="reserve" id="reserve"></div>
      </div>
      <div class="panel">
        <b>공격 안내</b>
        <div style="margin-top:6px">
          <small>1턴은 전체 사용 가능. 2턴부터 직전 턴 사용 기물은 회색 표시되고 사용 불가.</small>
        </div>
      </div>
    </div>

    <div>
      <div class="center" style="margin-bottom:6px;">적 보드</div>
      <div class="board" id="boardAI"></div>
    </div>
  </div>

  <div class="log" id="log"></div>
</div>

<script>
/* ===== 상수 ===== */
const BOARD_SIZE=5, PREP_TIME=20, ATTACK_TIME=8, MAX_TURN=10, AI_TURN_DELAY=1000;

/* ===== 데이터 ===== */
const FACTIONS={
  "수인":["디아나","티그","루포","버터","코미","베니","베니","베니"],
  "요정":["에르핀","네르","죠안","에슈르","마요(멋짐)","마리","마리","마리"],
  "마녀":["벨리타","프리클","셰럼","마카샤","포셔","레비","레비","레비"]
};
const PATTERNS={
  "디아나":"plus1","티그":"diag1","루포":"cross2","버터":"square1","코미":"line2","베니":"plus1",
  "에르핀":"diag1","네르":"cross2","죠안":"plus1","에슈르":"line2","마요(멋짐)":"square1","마리":"plus1",
  "벨리타":"line2","프리클":"diag1","셰럼":"plus1","마카샤":"cross2","포셔":"square1","레비":"plus1"
};
const HP_TABLE={
  "디아나":3,"버터":2,"티그":2,"루포":2,"코미":2,"베니":1,
  "벨리타":3,"프리클":2,"마카샤":2,"셰럼":2,"포셔":2,"레비":1,
  "에르핀":3,"네르":2,"죠안":2,"에슈르":2,"마요(멋짐)":2,"마리":1
};

/* ===== 유닛 이미지 경로 매핑 =====
   실제 PNG 파일 경로에 맞게 수정해서 사용하세요.
   예: /img/diana.png 를 배포 리포지토리에 올려두기 */
const UNIT_IMAGES = {
  "디아나":"img/디아나.png",
  "티그":"img/티그.png",
  "루포":"img/루포.png",
  "버터":"img/버터.png",
  "코미":"img/코미.png",
  "베니":"img/베니.png",
  "에르핀":"img/에르핀.png",
  "네르":"img/네르.png",
  "죠안":"img/죠안.png",
  "에슈르":"img/에슈르.png",
  "마요(멋짐)":"img/마요(멋짐).png",
  "마리":"img/마리.png",
  "벨리타":"img/벨리타.png",
  "프리클":"img/프리클.png",
  "셰럼":"img/셰럼.png",
  "마카샤":"img/마카샤.png",
  "포셔":"img/포셔.png",
  "레비":"img/레비.png"
};
function getUnitImage(name){
  return UNIT_IMAGES[name] || "img/default.png";
}

/* ===== 점수 규칙 ===== */
const SCORE_TABLE = {
  "디아나":3, "에르핀":3, "벨리타":3,      // 왕
  "티그":2, "네르":2, "프리클":2, "루포":2, "마카샤":2, "죠안":2, "셰럼":2, "에슈르":2, "포셔":2, "마요(멋짐)":2, // 보좌관
  "버터":1, "코미":1, "베니":1, "마리":1, "레비":1 // 백성
};
function calcScore(board){
  let pieces=0, score=0;
  for(let r=0;r<BOARD_SIZE;r++) for(let c=0;c<BOARD_SIZE;c++){
    const u=board[r][c];
    if(u){
      pieces++;
      score += SCORE_TABLE[u.name] || 0;
    }
  }
  return {pieces,score};
}

/* ===== 왕 정의 ===== */
const KINGS = ["디아나", "에르핀", "벨리타"];
function hasKing(board){
  for(let r=0;r<BOARD_SIZE;r++) for(let c=0;c<BOARD_SIZE;c++){
    if(board[r][c] && KINGS.includes(board[r][c].name)) return true;
  }
  return false;
}

/* ===== 상태 ===== */
let myFaction=null, aiFaction=null;
let turn=1, phase="대기";
let timerId=null, timeLeft=0;

const me=Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(null));
const ai=Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(null));
let reserve=[], selectedReserve=null, pickUp=null;
let attackChoice=null, lastPreview=null, aiUnits=[], hasAttacked=false;

/* ===== 유틸 ===== */
const elBoardMe=document.getElementById('boardMe');
const elBoardAI=document.getElementById('boardAI');
const elReserve=document.getElementById('reserve');
const elAiOverlay=document.getElementById('aiOverlay');
const elNextOverlay=document.getElementById('nextOverlay');

for(let i=0;i<BOARD_SIZE*BOARD_SIZE;i++){
  const d=document.createElement('div');
  d.className='cell';
  d.dataset.idx=i;
  elBoardMe.appendChild(d);
}
for(let i=0;i<BOARD_SIZE*BOARD_SIZE;i++){
  const d=document.createElement('div');
  d.className='cell';
  d.dataset.idx=i;
  elBoardAI.appendChild(d);
}

function fmtTime(n){return String(n).padStart(2,'0')}
function log(msg){
  const el=document.getElementById('log');
  const t=new Date().toLocaleTimeString();
  el.innerHTML=`[${t}] ${msg}<br>`+el.innerHTML;
}
const delay=ms=>new Promise(r=>setTimeout(r,ms));
const nextFrame=()=>new Promise(r=>requestAnimationFrame(()=>r()));

/* ===== 렌더 ===== */
function renderBoards(){
  const cellsMe=elBoardMe.children;
  for(let i=0;i<BOARD_SIZE*BOARD_SIZE;i++){
    const r=Math.floor(i/BOARD_SIZE), c=i%BOARD_SIZE;
    const v=me[r][c], el=cellsMe[i];
    el.classList.remove('preview');
    renderCell(el, v, true, v ? (turn>1 && v.lastUsedTurn===turn-1) : false);
  }
  for(let i=0;i<BOARD_SIZE*BOARD_SIZE;i++){
    const el=elBoardAI.children[i];
    el.textContent="";
    el.title="";
    el.classList.remove('preview');
  }
  if(lastPreview){ previewOn(lastPreview.r,lastPreview.c,true); }
}

/* 핵심 변경: 플레이어 보드에는 이미지 + HP바, 적 보드는 기존처럼 텍스트만(또는 비공개) */
function renderCell(el, unit, showHp, cd){
  if(!unit){
    if(!el.classList.contains('kill')){
      el.innerHTML="";
      el.title="";
    }
    return;
  }
  const {name,hp,max}=unit;

  if(showHp){
    // 플레이어 보드: 캐릭터 이미지 + HP바
    const imgSrc = getUnitImage(name);
    el.innerHTML = `
      <div class="unit">
        <img class="unit-img" src="${imgSrc}" alt="${name}">
        <div class="hpbar">
          ${Array.from({length:max},(_,i)=>`<div class="hpseg ${i<hp?'on':''}"></div>`).join('')}
        </div>
      </div>
    `;
  }else{
    // 적 보드 혹은 텍스트만 필요할 때
    el.innerHTML = name;
  }
  el.title = `${name} HP ${hp}/${max}`;
}

function setPhase(p, seconds=0){
  phase=p;
  document.getElementById('phase').textContent=p;
  clearInterval(timerId);
  timeLeft=seconds;
  document.getElementById('timer').textContent=fmtTime(timeLeft);
  if(seconds>0){
    timerId=setInterval(()=>{
      timeLeft--;
      document.getElementById('timer').textContent=fmtTime(timeLeft);
      if(timeLeft<=0){
        clearInterval(timerId);
        onTimerEnd();
      }
    },1000);
  }
}

/* ===== 흐릿표시 초기화 ===== */
function clearEnemyMarks(){[...elBoardAI.children].forEach(el=>el.classList.remove('preview','hit','kill'))}
function clearMyMarks(){[...elBoardMe.children].forEach(el=>el.classList.remove('preview','hit','kill'))}

/* ===== 유닛 ===== */
function createUnit(name){
  const max=HP_TABLE[name]||1;
  return {name, hp:max, max, lastUsedTurn:-1}; // 핵심: -1로 초기화
}

/* ===== 단계 전환 타이머 ===== */
function onTimerEnd(){
  if(phase==="준비") finishPrepare();
  else if(phase==="공격") autoAttackIfNone();
}

/* ===== 진영 배정 → 준비 ===== */
function assignFactions(){
  const keys=Object.keys(FACTIONS);
  myFaction=keys[Math.floor(Math.random()*keys.length)];
  document.getElementById('myFaction').textContent=myFaction;
  log(`내 진영 배정: ${myFaction}`);
  setTimeout(()=>{
    const others=keys.filter(k=>k!==myFaction);
    aiFaction=others[Math.floor(Math.random()*others.length)];
    document.getElementById('aiFaction').textContent=aiFaction;
    log(`상대 진영 배정: ${aiFaction}`);
    startPrepare();
  },800);
}
function startPrepare(){
  for(let r=0;r<BOARD_SIZE;r++) for(let c=0;c<BOARD_SIZE;c++) me[r][c]=null;
  reserve=[...FACTIONS[myFaction]].sort((a,b)=>a.localeCompare(b));
  selectedReserve=null; pickUp=null; attackChoice=null; lastPreview=null;
  aiRandomFill();
  renderReserve();
  renderBoards();
  setPhase("준비", PREP_TIME);
  log("준비 단계 시작. 배치 후 [준비 종료].");
}
function renderReserve(){
  elReserve.innerHTML="";
  reserve.forEach((name,idx)=>{
    const d=document.createElement('div');
    d.className='chip'+(selectedReserve===idx?' sel':'');

    d.textContent=name;
    d.title=`패턴:${PATTERNS[name]} · HP ${HP_TABLE[name]}`;

    d.onclick=()=>{
      selectedReserve = (selectedReserve===idx? null: idx);
      pickUp=null;
      renderReserve();
    };
    elReserve.appendChild(d);
  });
  document.getElementById('reserveInfo').textContent=`(남은 ${reserve.length}/8)`;
}
function finishPrepare(){
  while(reserve.length){
    const name=reserve.shift();
    const empty=[];
    for(let r=0;r<BOARD_SIZE;r++) for(let c=0;c<BOARD_SIZE;c++) if(!me[r][c]) empty.push({r,c});
    if(!empty.length) break;
    const {r,c}=empty[Math.floor(Math.random()*empty.length)];
    me[r][c]=createUnit(name);
  }
  renderReserve();
  renderBoards();
  log("준비 단계 종료.");
  startAttack();
}
function aiRandomFill(){
  for(let r=0;r<BOARD_SIZE;r++) for(let c=0;c<BOARD_SIZE;c++) ai[r][c]=null;
  const pool=[...FACTIONS[aiFaction]];
  while(pool.length){
    const name=pool.shift();
    const empty=[];
    for(let r=0;r<BOARD_SIZE;r++) for(let c=0;c<BOARD_SIZE;c++) if(!ai[r][c]) empty.push({r,c});
    if(!empty.length) break;
    const {r,c}=empty[Math.floor(Math.random()*empty.length)];
    ai[r][c]=createUnit(name);
  }
  collectAiUnits();
}
function collectAiUnits(){
  aiUnits=[];
  for(let r=0;r<BOARD_SIZE;r++) for(let c=0;c<BOARD_SIZE;c++) if(ai[r][c]){
    aiUnits.push({r,c,name:ai[r][c].name,lastUsedTurn:ai[r][c].lastUsedTurn});
  }
}

/* ===== 공격 단계 ===== */
function startAttack(){
  hasAttacked=false;
  setPhase("공격", ATTACK_TIME);
  attackChoice=null; lastPreview=null;
  clearEnemyMarks(); clearMyMarks();
  renderBoards();
  log(`공격 단계 시작. 턴 ${turn}. 한 턴에 한 기물만 공격.`);
}
function selectableMyUnits(){
  const list=[];
  for(let r=0;r<BOARD_SIZE;r++) for(let c=0;c<BOARD_SIZE;c++){
    const u=me[r][c];
    if(u && u.hp>0 && (turn===1 || u.lastUsedTurn!==turn-1)) list.push({r,c,name:u.name});
  }
  return list;
}
function autoAttackIfNone(){
  if(attackChoice){ beginBattle(); return; }
  const list=selectableMyUnits();
  if(!list.length){
    log("사용 가능한 기물이 없어 공격을 건너뜁니다.");
    beginBattle();
    return;
  }
  hasAttacked=true;
  const unit=list[Math.floor(Math.random()*list.length)];
  const target={r:Math.floor(Math.random()*BOARD_SIZE), c:Math.floor(Math.random()*BOARD_SIZE)};
  attackChoice={unitAt:unit, target};
  log(`시간 초과. 랜덤 공격: ${unit.name} → (${target.r+1},${target.c+1})`);
  beginBattle();
}

/* ===== 전투 처리 ===== */
function applyAttack(boardEl, boardData, attackerName, target){
  const pattern=PATTERNS[attackerName]||"plus1";
  const ofs=patternOffsets(pattern);
  let hits=0,kills=0;
  ofs.forEach(([dr,dc])=>{
    const rr=target.r+dr, cc=target.c+dc;
    if(rr<0||cc<0||rr>=BOARD_SIZE||cc>=BOARD_SIZE) return;
    const idx=rr*BOARD_SIZE+cc, el=boardEl.children[idx];
    el.classList.add('hit');
    if(boardData[rr][cc]){
      boardData[rr][cc].hp -= 1;
      if(boardData[rr][cc].hp<=0){
        boardData[rr][cc]=null;
        kills++;
        el.classList.add('kill');
        if(boardEl===elBoardMe){
          el.innerHTML="";
          el.title="";
        }
      }else{
        if(boardEl===elBoardMe)
          renderCell(el, boardData[rr][cc], true, (turn>1 && boardData[rr][cc].lastUsedTurn===turn-1));
      }
    }
    hits++;
  });
  return {pattern,hits,kills};
}
function beginBattle(){
  setPhase("전투");
  // 내 공격
  if(attackChoice){
    const {unitAt,target}=attackChoice;
    const myUnit=me[unitAt.r][unitAt.c];
    if(myUnit){
      myUnit.lastUsedTurn = turn;
      const res=applyAttack(elBoardAI, ai, myUnit.name, target);
      collectAiUnits();
      log(`전투: ${myUnit.name} 패턴[${res.pattern}] 타격 ${res.hits}, 격파 ${res.kills}.`);
    }
  }else{
    log("공격 없음.");
  }
  // 상대 왕 즉사 체크
  if(!hasKing(ai)){
    log("승리: 상대 왕이 사망했습니다.");
    setPhase("종료");
    showResultPopup();
    return;
  }
  // AI 반격
  enemyCounterAndEnd();
}

/* ===== AI 반격 + 턴 종료 ===== */
async function enemyCounterAndEnd(){
  const able = aiUnits.filter(u => (turn===1 || u.lastUsedTurn!==turn-1));
  if(able.length>0){
    setPhase("상대턴");
    elAiOverlay.style.display='flex';
    await nextFrame();
    await delay(AI_TURN_DELAY);
    clearMyMarks();
    const aiUnit=able[Math.floor(Math.random()*able.length)];
    const targetMe={r:Math.floor(Math.random()*BOARD_SIZE), c:Math.floor(Math.random()*BOARD_SIZE)};
    const res2=applyAttack(elBoardMe, me, aiUnit.name, targetMe);
    if(ai[aiUnit.r][aiUnit.c]) ai[aiUnit.r][aiUnit.c].lastUsedTurn = turn;
    log(`적 반격: ${aiUnit.name} 타격 ${res2.hits}, 격파 ${res2.kills}.`);
    elAiOverlay.style.display='none';
  }else{
    log("상대는 이번 턴에 사용할 기물이 없음.");
  }
  // 아군 왕 즉사 체크
  if(!hasKing(me)){
    log("패배: 아군 왕이 사망했습니다.");
    setPhase("종료");
    showResultPopup();
    return;
  }
  // 전멸 체크
  if(countUnits(ai)===0 || countUnits(me)===0){
    setPhase("종료");
    showResultPopup();
    return;
  }
  endTurn();
}
function countUnits(board){
  let n=0;
  for(let r=0;r<BOARD_SIZE;r++) for(let c=0;c<BOARD_SIZE;c++) if(board[r][c]) n++;
  return n;
}
async function endTurn(){
  if(turn >= MAX_TURN){
    setPhase("종료");
    showResultPopup();
    return;
  }
  turn++;
  document.getElementById('turn').textContent=turn;
  elNextOverlay.style.display='flex';
  await nextFrame();
  await delay(600);
  elNextOverlay.style.display='none';
  startAttack();
}

/* ===== 상호작용 ===== */
elBoardMe.addEventListener('click', (e)=>{
  const cell=e.target.closest('.cell');
  if(!cell) return;
  const idx=+cell.dataset.idx;
  const r=Math.floor(idx/BOARD_SIZE), c=idx%BOARD_SIZE;

  if(phase==="준비"){
    if(selectedReserve!=null && !me[r][c]){
      const name=reserve.splice(selectedReserve,1)[0];
      selectedReserve=null;
      me[r][c]=createUnit(name);
      renderReserve();
      renderBoards();
    }else if(me[r][c] && !pickUp){
      pickUp={r,c};
    }else if(pickUp){
      if(!me[r][c]){
        me[r][c]=me[pickUp.r][pickUp.c];
        me[pickUp.r][pickUp.c]=null;
      }
      pickUp=null;
      renderBoards();
    }
  }else if(phase==="공격"){
    if(hasAttacked) return;
    if(attackChoice && attackChoice.unitAt) return;
    const u=me[r][c];
    if(!u) return;
    if(turn>1 && u.lastUsedTurn===turn-1){
      log("직전 턴에 사용한 기물은 이번 턴에 사용할 수 없습니다.");
      return;
    }
    attackChoice={unitAt:{r,c,name:u.name}, target:null};
    log(`선택: ${u.name} (내 보드 ${r+1},${c+1})`);
  }
});

elBoardAI.addEventListener('click', (e)=>{
  if(phase!=="공격" || hasAttacked || !attackChoice || !attackChoice.unitAt) return;
  const cell=e.target.closest('.cell');
  if(!cell) return;
  const idx=+cell.dataset.idx;
  const r=Math.floor(idx/BOARD_SIZE), c=idx%BOARD_SIZE;

  if(lastPreview && lastPreview.r===r && lastPreview.c===c){
    hasAttacked=true;
    attackChoice.target={r,c};
    log(`공격 확정: (${r+1},${c+1})`);
    beginBattle();
    return;
  }
  previewOn(r,c,false);
});

function previewOn(r,c,keep=false){
  clearEnemyMarks();
  lastPreview={r,c};
  const name = me[attackChoice.unitAt.r][attackChoice.unitAt.c].name;
  const pattern = PATTERNS[name]||"plus1";
  const ofs = patternOffsets(pattern);
  ofs.forEach(([dr,dc])=>{
    const rr=r+dr, cc=c+dc;
    if(rr<0||cc<0||rr>=BOARD_SIZE||cc>=BOARD_SIZE) return;
    elBoardAI.children[rr*BOARD_SIZE+cc].classList.add('preview');
  });
  if(!keep) log(`미리보기: (${r+1},${c+1}), 패턴[${pattern}]`);
}

/* ===== 패턴 ===== */
function patternOffsets(k){
  switch(k){
    case "plus1": return [[1,0],[-1,0],[0,1],[0,-1]];
    case "diag1": return [[1,1],[1,-1],[-1,1],[-1,-1]];
    case "cross2": return [[1,0],[-1,0],[0,1],[0,-1],[2,0],[-2,0],[0,2],[0,-2]];
    case "square1": return [[0,0],[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
    case "line2": return [[1,0],[2,0],[-1,0],[-2,0],[0,1],[0,2],[0,-1],[0,-2]];
    default: return [[0,0]];
  }
}

/* ===== 결과 ===== */
function showResultPopup(){
  const myRes = calcScore(me);
  const aiRes = calcScore(ai);
  let winner = "무승부";
  if(myRes.score > aiRes.score) winner="플레이어 승";
  else if(myRes.score < aiRes.score) winner="AI 승";

  const html = `
    <p>플레이어 남은 기물: <b>${myRes.pieces}</b>개 (${myRes.score}점)</p>
    <p>상대 남은 기물: <b>${aiRes.pieces}</b>개 (${aiRes.score}점)</p>
    <hr style="border:none;border-top:1px solid #2b3242;margin:8px 0;">
    <p><b>결과: ${winner}</b></p>
  `;
  document.getElementById('resultContent').innerHTML = html;
  document.getElementById('resultOverlay').style.display='flex';
}
document.getElementById('btnRestart').onclick=()=>{ location.reload(); };

/* ===== 버튼 ===== */
document.getElementById('btnStart').onclick=()=>{
  document.getElementById('overlay').style.display='none';
  document.getElementById('turnTotal').textContent=MAX_TURN;
  setPhase("진영배정");
  assignFactions();
};
document.getElementById('btnReady').onclick=()=>{ if(phase==="준비") finishPrepare(); };
document.getElementById('btnReset').onclick=()=>{ location.reload(); };
document.getElementById('btnSurrender').onclick=()=>{
  setPhase("종료");
  log("항복. 패배 처리.");
};

/* ===== 초기 렌더 ===== */
renderBoards();
renderReserve();
</script>
</body>
</html>
